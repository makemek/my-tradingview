import { Buffer } from 'buffer'
import { logger } from 'lib/logger'
import { ioFilter } from 'core/modules/common/helpers'
import pick from 'lodash/pick'
import { of } from 'rxjs'
import { map, mergeMap, filter } from 'rxjs/operators'

import { compose, decompose } from './payload'
import { isHeartbeat } from './heartbeat'
import { Builder } from './protobuf'
import { CommandFieldConverter } from './command'
import { schema } from 'core/modules/common/schema'

const log = logger('core:message')
const builder = new Builder(schema)
const commandConverter = new CommandFieldConverter(schema)

export function routeMessage(stream$) {
  return stream$.pipe(
    mergeMap(({ payload }) => {
      if (typeof payload === 'string') {
        return handleStringMessage(payload, stream$)
      }
      return handleBufferMessage(payload, stream$)
    }),
  )
}

export function handleStringMessage(rawMessage, stream$) {
  return of(rawMessage).pipe(
    map(function decomposeEmbeddedMessages(embeddedMessages) {
      return decompose.withStringPayload(embeddedMessages)
    }),
    filter(function heartbeatWithoutSigature([firstMessage]) {
      const heartbeatWithoutSigature = !firstMessage.signature
      if (heartbeatWithoutSigature) {
        stream$.complete(firstMessage.payload)
        return false
      }
      return true
    }),
    filter(function heartbeat(messages) {
      const [firstMessage] = messages
      const heartbeatSignature = firstMessage.payload.slice(0, 4)
      if (messages.length === 1 && isHeartbeat(heartbeatSignature)) {
        log('string:heartbeat', heartbeatSignature)
        ioFilter
          .apply('heartbeat', heartbeatSignature)
          .subscribe((value) => stream$.complete(value))
        return false
      }

      return true
    }),
    mergeMap(function transformMessages([message]) {
      const { payload } = message
      const { m: command, p: data } = JSON.parse(payload)
      const commandFields = commandConverter.toCommandFields(
        command,
        data,
      )
      return ioFilter.apply(command, commandFields).pipe(
        map(({ payload: modifiedData }) => {
          const cleanModifiedData = _cleanForignFields(
            modifiedData,
            command,
          )
          const fieldArray = commandConverter.toFieldArray(
            command,
            cleanModifiedData,
          )
          const inputPayload = JSON.stringify({
            m: command,
            p: fieldArray,
          })
          log('string:decomposed', command, data)
          return compose.withStringPayload(inputPayload)
        }),
      )
    }),
  )
}

export function handleBufferMessage(rawMessage, stream$) {
  return of(rawMessage).pipe(
    map(function decomposeEmbeddedMessages(embeddedMessages) {
      return decompose.withBufferPayload(embeddedMessages)
    }),
    filter(function heartbeat(messages) {
      const [firstMessage] = messages
      const heartbeatSignature = Buffer.from(
        firstMessage.payload.slice(0, 4),
      ).toString()
      if (messages.length === 1 && isHeartbeat(heartbeatSignature)) {
        log('buffer:heartbeat', heartbeatSignature)
        ioFilter
          .apply('heartbeat', heartbeatSignature)
          .subscribe((value) => stream$.complete(value))
        return false
      }
      return true
    }),
    mergeMap(function transformMessages(message) {
      const { payload } = message
      const { command, data } = builder.decode(payload)
      return ioFilter.apply(command, data).pipe(
        map(({ payload: modifiedData }) => {
          const cleanModifiedData = _cleanForignFields(
            modifiedData,
            command,
          )
          const inputPayload = builder.encode(
            command,
            cleanModifiedData,
          )
          log('buffer:decomposed', command, data)
          return compose.withBufferPayload(inputPayload)
        }),
      )
    }),
  )
}

/**
 * Remove fields that maybe generated by Filter's listeners
 * to prevent protobuf error thrown when encoding a message.
 */
function _cleanForignFields(message, command) {
  return pick(
    message,
    commandConverter.getField(command).map(({ name }) => name),
  )
}
